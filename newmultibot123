import ccxt
import pandas as pd
import numpy as np
import time
from datetime import datetime
import logging
import os
import json

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("multi_crypto_trading_bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('multi_crypto_bot')

class MarketAnalyzer:
    """Eine separate Klasse zur Analyse des Gesamtmarkts und der Trading-Performance"""
    
    def __init__(self, bot):
        self.bot = bot
        self.trade_history = []
        self.market_state = 'neutral'  # 'bullish', 'bearish', 'neutral', 'volatile'
        self.symbol_correlation = {}
        self.performance_metrics = {
            'win_rate': 0,
            'profit_factor': 0,
            'avg_win': 0,
            'avg_loss': 0,
            'largest_win': 0,
            'largest_loss': 0,
            'consecutive_wins': 0,
            'consecutive_losses': 0
        }
        
        # Pfad für CSV-Export
        self.export_path = 'trading_performance.csv'
        
        # Performance nach Symbol
        self.symbol_performance = {symbol: {
            'trades': 0,
            'wins': 0,
            'losses': 0,
            'total_profit': 0,
            'best_time': None  # Tageszeit mit bester Performance
        } for symbol in bot.symbols}
        
    def record_trade(self, symbol, entry_price, exit_price, position_type, 
                    entry_time, exit_time, profit_loss_percent):
        """Zeichnet einen abgeschlossenen Trade auf"""
        trade = {
            'symbol': symbol,
            'entry_price': entry_price,
            'exit_price': exit_price,
            'position_type': position_type,
            'entry_time': entry_time,
            'exit_time': exit_time,
            'profit_loss_percent': profit_loss_percent,
            'duration': (exit_time - entry_time).total_seconds() / 60,  # in Minuten
            'market_state': self.market_state
        }
        
        self.trade_history.append(trade)
        
        # Update Symbol-Performance
        self.symbol_performance[symbol]['trades'] += 1
        if profit_loss_percent > 0:
            self.symbol_performance[symbol]['wins'] += 1
            self.symbol_performance[symbol]['total_profit'] += profit_loss_percent
        else:
            self.symbol_performance[symbol]['losses'] += 1
            self.symbol_performance[symbol]['total_profit'] += profit_loss_percent
        
        # Exportiere in CSV
        self.export_trade_history()
        
        # Aktualisiere Performance-Metriken
        self.update_performance_metrics()
        
        return trade
    
    def analyze_market_state(self):
        """Analysiert den Gesamtmarktzustand basierend auf Indizes oder führenden Kryptowährungen"""
        try:
            # Hole Daten für BTC als Marktindikator
            btc_df = self.bot.fetch_ohlcv_data('BTCUSDT')
            if btc_df is None:
                return
                
            btc_df = self.bot.calculate_indicators(btc_df)
            
            # Analysiere Trend von BTC
            close = btc_df['close'].iloc[-1]
            sma200 = btc_df['close'].rolling(window=200).mean().iloc[-1]
            rsi = btc_df['rsi'].iloc[-1]
            volatility = btc_df['close'].pct_change().rolling(window=10).std().iloc[-1] * 100
            
            # Bestimme Marktbedingungen
            if close > sma200 and rsi > 55:
                self.market_state = 'bullish'
            elif close < sma200 and rsi < 45:
                self.market_state = 'bearish'
            elif volatility > 4:  # Hohe Volatilität
                self.market_state = 'volatile'
            else:
                self.market_state = 'neutral'
                
            logger.info(f"Current market state: {self.market_state} (BTC RSI: {rsi:.2f}, Volatility: {volatility:.2f}%)")
            
            return self.market_state
            
        except Exception as e:
            logger.error(f"Error analyzing market state: {e}")
            return 'neutral'
    
    def calculate_correlations(self):
        """Berechnet die Korrelation zwischen verschiedenen Kryptowährungen"""
        try:
            # Sammle Schlusskurse für alle Symbole
            price_data = {}
            for symbol in self.bot.symbols:
                df = self.bot.fetch_ohlcv_data(symbol)
                if df is not None:
                    price_data[symbol] = df['close'].values
            
            # Berechne Korrelationsmatrix
            if len(price_data) >= 2:
                price_df = pd.DataFrame(price_data)
                correlation_matrix = price_df.corr()
                
                # Speichere Korrelation für Handelslogik
                self.symbol_correlation = correlation_matrix.to_dict()
                
                # Log stark korrelierte Paare (>0.8)
                correlated_pairs = []
                for i, symbol1 in enumerate(self.bot.symbols):
                    for symbol2 in self.bot.symbols[i+1:]:
                        if symbol1 in correlation_matrix and symbol2 in correlation_matrix:
                            corr = correlation_matrix.loc[symbol1, symbol2]
                            if abs(corr) > 0.8:
                                correlated_pairs.append(f"{symbol1}-{symbol2}: {corr:.2f}")
                
                if correlated_pairs:
                    logger.info(f"Highly correlated pairs: {', '.join(correlated_pairs)}")
                
                return self.symbol_correlation
                
        except Exception as e:
            logger.error(f"Error calculating correlations: {e}")
            return {}
    
    def update_performance_metrics(self):
        """Aktualisiert Trading-Performance-Metriken"""
        if not self.trade_history:
            return
            
        wins = [t for t in self.trade_history if t['profit_loss_percent'] > 0]
        losses = [t for t in self.trade_history if t['profit_loss_percent'] <= 0]
        
        # Win-Rate und Profit-Faktor
        self.performance_metrics['win_rate'] = len(wins) / len(self.trade_history) if self.trade_history else 0
        total_profit = sum(t['profit_loss_percent'] for t in wins)
        total_loss = abs(sum(t['profit_loss_percent'] for t in losses))
        self.performance_metrics['profit_factor'] = total_profit / total_loss if total_loss > 0 else float('inf')
        
        # Durchschnitte und Extremwerte
        self.performance_metrics['avg_win'] = sum(t['profit_loss_percent'] for t in wins) / len(wins) if wins else 0
        self.performance_metrics['avg_loss'] = sum(t['profit_loss_percent'] for t in losses) / len(losses) if losses else 0
        self.performance_metrics['largest_win'] = max([t['profit_loss_percent'] for t in wins]) if wins else 0
        self.performance_metrics['largest_loss'] = min([t['profit_loss_percent'] for t in losses]) if losses else 0
        
        # Logarithme die Performance
        metrics_str = ", ".join([f"{k}: {v:.2f}" for k, v in self.performance_metrics.items() 
                                if isinstance(v, (int, float))])
        logger.info(f"Performance metrics updated: {metrics_str}")
        
        # Analysiere beste Handelszeiten
        self.analyze_best_trading_times()
        
    def analyze_best_trading_times(self):
        """Analysiert zu welchen Zeiten die besten Trades stattfinden"""
        if len(self.trade_history) < 10:
            return
            
        for symbol in self.bot.symbols:
            symbol_trades = [t for t in self.trade_history if t['symbol'] == symbol]
            if not symbol_trades:
                continue
                
            # Gruppiere Trades nach Stunde
            trades_by_hour = {}
            for trade in symbol_trades:
                hour = trade['entry_time'].hour
                if hour not in trades_by_hour:
                    trades_by_hour[hour] = []
                trades_by_hour[hour].append(trade['profit_loss_percent'])
            
            # Finde die profitabelste Stunde
            best_hour = None
            best_profit = -float('inf')
            
            for hour, profits in trades_by_hour.items():
                if len(profits) >= 3:  # Mindestens 3 Trades für Signifikanz
                    avg_profit = sum(profits) / len(profits)
                    if avg_profit > best_profit:
                        best_profit = avg_profit
                        best_hour = hour
            
            if best_hour is not None:
                self.symbol_performance[symbol]['best_time'] = best_hour
                logger.info(f"{symbol} performs best at hour {best_hour} with avg profit {best_profit:.2f}%")
    
    def export_trade_history(self):
        """Exportiert Trade-Historie in CSV-Datei"""
        try:
            if not self.trade_history:
                return
                
            df = pd.DataFrame(self.trade_history)
            df.to_csv(self.export_path, index=False)
            
        except Exception as e:
            logger.error(f"Error exporting trade history: {e}")
    
    def get_optimized_parameters(self, symbol):
        """Gibt optimierte Parameter für ein Symbol basierend auf Performance zurück"""
        try:
            # Standardparameter
            params = {
                'rsi_period': self.bot.rsi_period,
                'rsi_overbought': self.bot.rsi_overbought,
                'rsi_oversold': self.bot.rsi_oversold,
                'short_sma': self.bot.short_sma,
                'long_sma': self.bot.long_sma
            }
            
            symbol_trades = [t for t in self.trade_history if t['symbol'] == symbol]
            if len(symbol_trades) < 20:
                return params  # Zu wenige Trades für Optimierung
                
            # Analysiere Performance und passe Parameter an
            win_rate = len([t for t in symbol_trades if t['profit_loss_percent'] > 0]) / len(symbol_trades)
            avg_profit = sum(t['profit_loss_percent'] for t in symbol_trades) / len(symbol_trades)
            
            # Wenn Win-Rate niedrig ist, passe Parameter an
            if win_rate < 0.4:
                # Konservativere RSI-Werte
                params['rsi_overbought'] = 75
                params['rsi_oversold'] = 25
                
                # Längere SMAs für stabileren Trend
                params['short_sma'] = 25
                params['long_sma'] = 60
            
            # Wenn Win-Rate gut ist, aber Durchschnittsgewinn niedrig
            elif win_rate > 0.5 and avg_profit < 1.0:
                # Aggressivere Take-Profit-Einstellungen
                params['take_profit_percent'] = self.bot.take_profit_percent * 1.2
            
            # Wenn alles gut läuft, optimiere für höhere Frequenz
            elif win_rate > 0.6 and avg_profit > 2.0:
                # Schnellere Reaktion auf Marktsignale
                params['short_sma'] = 15
                params['rsi_period'] = 10
                
            logger.info(f"Optimized parameters for {symbol}: {params}")
            return params
            
        except Exception as e:
            logger.error(f"Error optimizing parameters: {e}")
            return {
                'rsi_period': self.bot.rsi_period,
                'rsi_overbought': self.bot.rsi_overbought,
                'rsi_oversold': self.bot.rsi_oversold,
                'short_sma': self.bot.short_sma,
                'long_sma': self.bot.long_sma
            }

class MultiCryptoBot:
    def __init__(self, api_key, api_secret, password, 
                 symbols=['SOLUSDT', 'XRPUSDT', 'ETHUSDT', 'BTCUSDT', 'ADAUSDT', 'LINKUSDT'], 
                 timeframe='15m', 
                 rsi_period=14, 
                 rsi_overbought=70, 
                 rsi_oversold=30, 
                 short_sma=20, 
                 long_sma=50, 
                 stop_loss_percent=2.5, 
                 take_profit_percent=5.5, 
                 leverage=5):
        self.api_key = api_key
        self.api_secret = api_secret
        self.password = password
        self.symbols = symbols
        self.timeframe = timeframe
        self.leverage = leverage
        
        # Strategy parameters
        self.rsi_period = rsi_period
        self.rsi_overbought = rsi_overbought
        self.rsi_oversold = rsi_oversold
        self.short_sma = short_sma
        self.long_sma = long_sma
        
        # Risk management
        self.stop_loss_percent = stop_loss_percent / 100
        self.take_profit_percent = take_profit_percent / 100
        
        # Bot state for each symbol
        self.positions = {symbol: {
            'in_position': False,
            'position_type': None,  # 'long' or 'short'
            'position_entry_price': 0,
            'position_size': 0,
            'stop_loss': None,
            'take_profit': None,
            'entry_time': None
        } for symbol in symbols}
        
        # Exchange connection
        self.exchange = None
        self.initialize_exchange()
        
        # Marktanalysator
        self.market_analyzer = MarketAnalyzer(self)
        
        # Load trade history if exists
        self.load_trade_history()
        
        logger.info(f"Enhanced Multi-Crypto Bot initialized for symbols: {', '.join(symbols)}")
    
    def load_trade_history(self):
        """Lädt die Trading-Historie, falls vorhanden"""
        try:
            if os.path.exists('trading_performance.csv'):
                df = pd.read_csv('trading_performance.csv')
                
                for _, row in df.iterrows():
                    trade = {
                        'symbol': row['symbol'],
                        'entry_price': row['entry_price'],
                        'exit_price': row['exit_price'],
                        'position_type': row['position_type'],
                        'entry_time': pd.to_datetime(row['entry_time']),
                        'exit_time': pd.to_datetime(row['exit_time']),
                        'profit_loss_percent': row['profit_loss_percent'],
                        'duration': row['duration'],
                        'market_state': row['market_state']
                    }
                    self.market_analyzer.trade_history.append(trade)
                
                logger.info(f"Loaded {len(self.market_analyzer.trade_history)} historical trades")
        except Exception as e:
            logger.error(f"Error loading trade history: {e}")
    
    def initialize_exchange(self):
        """Initialize exchange connection for live trading"""
        try:
            self.exchange = ccxt.bitget({
                'apiKey': self.api_key,
                'secret': self.api_secret,
                'password': self.password,
                'enableRateLimit': True,
                'options': {
                    'defaultType': 'swap',
                    'createMarketBuyOrderRequiresPrice': False,
                    'createMarketOrderRequiresPrice': False,
                    'defaultMarginMode': 'cross',
                }
            })
            
            self.exchange.load_markets()
            logger.info("Exchange successfully connected")
            return True
        except Exception as e:
            logger.error(f"Exchange initialization error: {e}")
            return False
    
    def set_leverage(self):
        """Set leverage for all symbols"""
        try:
            for symbol in self.symbols:
                params = {
                    'marginCoin': 'USDT',
                    'leverage': self.leverage,
                    'holdSide': 'long'
                }
                self.exchange.set_leverage(self.leverage, symbol, params=params)
                logger.info(f"Leverage set to {self.leverage}x for {symbol}")
            return True
        except Exception as e:
            logger.error(f"Error setting leverage: {e}")
            return False
    
    def fetch_ohlcv_data(self, symbol):
        """Fetch real-time market data for a specific symbol"""
        try:
            data = self.exchange.fetch_ohlcv(symbol, self.timeframe, limit=200)
            df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            return df
        except Exception as e:
            logger.error(f"Error fetching market data for {symbol}: {e}")
            return None
    
    def calculate_indicators(self, df):
        """Calculate advanced technical indicators"""
        try:
            # RSI calculation
            delta = df['close'].diff()
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)
            avg_gain = gain.rolling(window=self.rsi_period, min_periods=1).mean()
            avg_loss = loss.rolling(window=self.rsi_period, min_periods=1).mean()
            rs = avg_gain / avg_loss
            df['rsi'] = 100 - (100 / (1 + rs))
            
            # SMA calculation
            df['short_sma'] = df['close'].rolling(window=self.short_sma).mean()
            df['long_sma'] = df['close'].rolling(window=self.long_sma).mean()
            
            # Bollinger Bands
            df['middle_band'] = df['close'].rolling(window=20).mean()
            std = df['close'].rolling(window=20).std()
            df['upper_band'] = df['middle_band'] + (std * 2)
            df['lower_band'] = df['middle_band'] - (std * 2)
            
            # Momentum
            df['momentum'] = df['close'].diff(periods=5)
            
            # MACD
            df['ema12'] = df['close'].ewm(span=12, adjust=False).mean()
            df['ema26'] = df['close'].ewm(span=26, adjust=False).mean()
            df['macd'] = df['ema12'] - df['ema26']
            df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()
            df['macd_hist'] = df['macd'] - df['macd_signal']
            
            # Stochastic Oscillator
            lowest_low = df['low'].rolling(window=14).min()
            highest_high = df['high'].rolling(window=14).max()
            df['stoch_k'] = 100 * ((df['close'] - lowest_low) / (highest_high - lowest_low))
            df['stoch_d'] = df['stoch_k'].rolling(window=3).mean()
            
            # Average Directional Index (ADX)
            df['tr1'] = abs(df['high'] - df['low'])
            df['tr2'] = abs(df['high'] - df['close'].shift())
            df['tr3'] = abs(df['low'] - df['close'].shift())
            df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
            df['atr'] = df['tr'].rolling(window=14).mean()
            
            df['plus_dm'] = (df['high'] - df['high'].shift()).clip(lower=0)
            df['minus_dm'] = (df['low'].shift() - df['low']).clip(lower=0)
            
            # Überprüfung für echte Bewegungen
            df.loc[df['plus_dm'] > df['minus_dm'], 'minus_dm'] = 0
            df.loc[df['plus_dm'] < df['minus_dm'], 'plus_dm'] = 0
            
            df['plus_di'] = 100 * (df['plus_dm'].rolling(window=14).mean() / df['atr'])
            df['minus_di'] = 100 * (df['minus_dm'].rolling(window=14).mean() / df['atr'])
            
            df['dx'] = 100 * abs(df['plus_di'] - df['minus_di']) / (df['plus_di'] + df['minus_di']).replace(0, 0.0001)
            df['adx'] = df['dx'].rolling(window=14).mean()
            
            # Volume Weight
            df['volume_weight'] = df['volume'] / df['volume'].rolling(window=20).mean()
            
            # Price Rate of Change (ROC)
            df['roc'] = df['close'].pct_change(periods=10) * 100
            
            return df
        except Exception as e:
            logger.error(f"Error calculating indicators: {e}")
            return df

    def check_trade_signals(self, df, symbol):
        """
        Determine trading signals with advanced strategy
        
        Signal components:
        1. Trend component (SMA, MACD)
        2. Momentum component (RSI, Stochastic)
        3. Volatility component (Bollinger Bands, ATR)
        4. Volume component
        
        Each component contributes to a final score, which determines trade decision
        """
        try:
            # Get latest values
            latest_data = df.iloc[-1]
            prev_data = df.iloc[-2]
            
            # Initialize score components
            trend_score = 0
            momentum_score = 0
            volatility_score = 0
            volume_score = 0
            
            # 1. Trend component (range -3 to +3)
            # SMA signal
            if latest_data['short_sma'] > latest_data['long_sma']:
                trend_score += 1
            else:
                trend_score -= 1
                
            # MACD signal
            if latest_data['macd'] > latest_data['macd_signal'] and prev_data['macd'] <= prev_data['macd_signal']:
                trend_score += 2  # MACD cross is a strong signal
            elif latest_data['macd'] < latest_data['macd_signal'] and prev_data['macd'] >= prev_data['macd_signal']:
                trend_score -= 2
                
            # 2. Momentum component (range -3 to +3)
            # RSI signal
            if latest_data['rsi'] < self.rsi_oversold:
                momentum_score += 1.5
            elif latest_data['rsi'] > self.rsi_overbought:
                momentum_score -= 1.5
                
            # Stochastic signal
            if latest_data['stoch_k'] < 20 and latest_data['stoch_k'] > latest_data['stoch_d']:
                momentum_score += 1.5
            elif latest_data['stoch_k'] > 80 and latest_data['stoch_k'] < latest_data['stoch_d']:
                momentum_score -= 1.5
                
            # 3. Volatility component (range -2 to +2)
            # Bollinger Bands signal
            price_to_lower = (latest_data['close'] - latest_data['lower_band']) / latest_data['close'] * 100
            price_to_upper = (latest_data['upper_band'] - latest_data['close']) / latest_data['close'] * 100
            
            if price_to_lower <= 1.0:  # Close to lower band
                volatility_score += 1
            elif price_to_upper <= 1.0:  # Close to upper band
                volatility_score -= 1
                
            # ATR-based volatility
            atr_percent = latest_data['atr'] / latest_data['close'] * 100
            if atr_percent > 3:  # High volatility environment
                volatility_score = volatility_score * 0.7  # Reduce signal strength in high volatility
                
            # ADX signal (trend strength)
            if latest_data['adx'] > 25:  # Strong trend
                # Amplify trend signal
                trend_score = trend_score * 1.3
                
            # 4. Volume component (range -1 to +1)
            if latest_data['volume_weight'] > 1.5:  # Volume spike
                # Volume confirms price direction
                if latest_data['close'] > latest_data['open']:
                    volume_score += 1  # Bullish volume
                else:
                    volume_score -= 1  # Bearish volume
            
            # Marktbedingungen berücksichtigen
            market_state = self.market_analyzer.market_state
            if market_state == 'bullish':
                trend_score *= 1.2
                momentum_score *= 1.1
            elif market_state == 'bearish':
                trend_score *= 0.8
                momentum_score *= 0.9
            elif market_state == 'volatile':
                # In volatilen Märkten vorsichtiger sein
                momentum_score *= 0.8
                volatility_score *= 0.7
                
            # Berücksichtige Korrelation mit anderen Coins
            if symbol in self.market_analyzer.symbol_correlation:
                # Wenn BTCUSDT sehr korreliert ist und handelt
                if 'BTCUSDT' in self.market_analyzer.symbol_correlation[symbol]:
                    corr = self.market_analyzer.symbol_correlation[symbol]['BTCUSDT']
                    if abs(corr) > 0.8 and symbol != 'BTCUSDT':
                        if self.positions['BTCUSDT']['in_position']:
                            # Verstärke Signal in gleicher Richtung wie BTC
                            if self.positions['BTCUSDT']['position_type'] == 'long':
                                trend_score *= 1.2
                            else:
                                trend_score *= 0.8
                
            # Kombiniere Scores mit verschiedenen Gewichtungen
            final_score = (
                trend_score * 0.4 +      # 40% Gewicht
                momentum_score * 0.3 +   # 30% Gewicht
                volatility_score * 0.2 + # 20% Gewicht
                volume_score * 0.1       # 10% Gewicht
            )
            
            # Logge das Ergebnis
            logger.info(f"{symbol} signal analysis - Trend: {trend_score:.2f}, Momentum: {momentum_score:.2f}, "
                       f"Volatility: {volatility_score:.2f}, Volume: {volume_score:.2f}, Final: {final_score:.2f}")
            
            # Entscheidungsschwellen
            if final_score >= 1.2:
                return 'long'
            elif final_score <= -1.2:
                return 'short'
            else:
                return None
        
        except Exception as e:
            logger.error(f"Error checking trade signals for {symbol}: {e}")
            return None

    def check_exit_signal(self, df, symbol):
        """
        Check if we should exit the current position
        """
        try:
            position = self.positions[symbol]
            if not position['in_position']:
                return False
                
            position_type = position['position_type']
            entry_price = position['position_entry_price']
            stop_loss = position['stop_loss']
            take_profit = position['take_profit']
            entry_time = position['entry_time']
            
            current_price = df['close'].iloc[-1]
            latest_rsi = df['rsi'].iloc[-1]
            
            # Prüfe auf Stop-Loss oder Take-Profit
            if position_type == 'long':
                if current_price <= stop_loss:
                    logger.info(f"{symbol} Stop Loss triggered at {current_price:.4f}")
                    return True
                if current_price >= take_profit:
                    logger.info(f"{symbol} Take Profit triggered at {current_price:.4f}")
                    return True
                
                # Zusätzliche Exit-Bedingungen
                if latest_rsi >= self.rsi_overbought:
                    logger.info(f"{symbol} Exit signal: RSI overbought at {latest_rsi:.2f}")
                    return True
                
                # Exit, wenn MA-Kreuzung nach unten (Trendwechsel)
                if df['short_sma'].iloc[-2] > df['long_sma'].iloc[-2] and df['short_sma'].iloc[-1] <= df['long_sma'].iloc[-1]:
                    # Nur wenn im Gewinn
                    if current_price > entry_price:
                        logger.info(f"{symbol} Exit signal: SMA bearish cross")
                        return True
                
            else:  # Short position
                if current_price >= stop_loss:
                    logger.info(f"{symbol} Stop Loss triggered at {current_price:.4f}")
                    return True
                if current_price <= take_profit:
                    logger.info(f"{symbol} Take Profit triggered at {current_price:.4f}")
                    return True
                
                # Zusätzliche Exit-Bedingungen
                if latest_rsi <= self.rsi_oversold:
                    logger.info(f"{symbol} Exit signal: RSI oversold at {latest_rsi:.2f}")
                    return True
                
                # Exit, wenn MA-Kreuzung nach oben (Trendwechsel)
                if df['short_sma'].iloc[-2] < df['long_sma'].iloc[-2] and df['short_sma'].iloc[-1] >= df['long_sma'].iloc[-1]:
                    # Nur wenn im Gewinn
                    if current_price < entry_price:
                        logger.info(f"{symbol} Exit signal: SMA bullish cross")
                        return True 
                        # Zeitbasierter Exit (nach X Stunden, wenn keine klare Richtung)
            hours_in_trade = (datetime.now() - entry_time).total_seconds() / 3600
            
            # Nach 48 Stunden ohne klare Richtung (weniger als 1% Gewinn)
            if hours_in_trade > 48:
                if position_type == 'long' and current_price < entry_price * 1.01:
                    logger.info(f"{symbol} Time-based exit after {hours_in_trade:.1f} hours")
                    return True
                elif position_type == 'short' and current_price > entry_price * 0.99:
                    logger.info(f"{symbol} Time-based exit after {hours_in_trade:.1f} hours")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking exit signal for {symbol}: {e}")
            return False

    def update_trailing_stop(self, symbol, current_price):
        """Aktualisiert den Trailing-Stop-Loss für eine bestehende Position"""
        try:
            position = self.positions[symbol]
            if not position['in_position']:
                return False
                
            entry_price = position['position_entry_price']
            position_type = position['position_type']
            current_stop = position.get('stop_loss', None)
            
            # Aktiviere Trailing Stop erst ab einem gewissen Gewinn
            activation_percent = 0.7 * self.take_profit_percent  # 70% des Take-Profit Ziels
            
            if position_type == 'long':
                activation_price = entry_price * (1 + activation_percent)
                if current_price >= activation_price:
                    # Berechne neuen Trailing Stop (z.B. 2% unter aktuellem Preis)
                    new_stop = current_price * 0.98
                    
                    # Aktualisiere nur, wenn der neue Stop höher ist als der aktuelle
                    if current_stop is None or new_stop > current_stop:
                        self.positions[symbol]['stop_loss'] = new_stop
                        logger.info(f"{symbol} Trailing stop updated to {new_stop:.4f}")
                    
            else:  # short
                activation_price = entry_price * (1 - activation_percent)
                if current_price <= activation_price:
                    # Berechne neuen Trailing Stop (z.B. 2% über aktuellem Preis)
                    new_stop = current_price * 1.02
                    
                    # Aktualisiere nur, wenn der neue Stop niedriger ist als der aktuelle
                    if current_stop is None or new_stop < current_stop:
                        self.positions[symbol]['stop_loss'] = new_stop
                        logger.info(f"{symbol} Trailing stop updated to {new_stop:.4f}")
    
        except Exception as e:
            logger.error(f"Error updating trailing stop for {symbol}: {e}")

    def calculate_position_size(self, symbol, current_price):
        """Berechnet die Positionsgröße basierend auf verschiedenen Risikometriken"""
        try:
            account_balance = float(self.exchange.fetch_balance()['total']['USDT'])
            
            # Berechne Volatilität für dynamisches Risiko
            df = self.fetch_ohlcv_data(symbol)
            if df is None:
                return None
                
            df['returns'] = df['close'].pct_change()
            volatility = df['returns'].std() * np.sqrt(24 * 60 / int(self.timeframe[:-1]))  # Skaliert auf tägliche Volatilität
            
            # Dynamische Risikoanpassung
            if volatility > 0.05:  # Hohe Volatilität (>5% täglich)
                risk_percent = 0.01  # Reduziere Risiko auf 1%
            else:
                risk_percent = 0.02  # Normales Risiko von 2%
            
            # Berücksichtige bereits offene Positionen
            open_positions_count = sum(1 for pos in self.positions.values() if pos['in_position'])
            max_positions = len(self.symbols) * 0.7  # Maximal 70% der beobachteten Symbole gleichzeitig im Handel
            
            if open_positions_count >= max_positions:
                risk_percent *= 0.5  # Reduziere Risiko bei vielen offenen Positionen
            
            # Berücksichtige Marktbedingungen
            if self.market_analyzer.market_state == 'volatile':
                risk_percent *= 0.7  # Reduziere Risiko in volatilen Märkten
            
            risk_amount = account_balance * risk_percent
            
            # Berechne Positionsgröße basierend auf Stop-Loss
            position_size = risk_amount / (current_price * self.stop_loss_percent)
            
            # Minimale und maximale Positionsgröße
            min_notional = 5  # Mindestens 5 USDT pro Trade
            max_percent = 0.1  # Maximal 10% des Kapitals pro Trade
            
            position_size = max(min_notional / current_price, min(position_size, account_balance * max_percent / current_price))
            
            # Runde Positionsgröße (je nach Symbol anpassen)
            position_size = round(position_size, 4)
            
            logger.info(f"{symbol} Position size calculated: {position_size:.4f} (${position_size * current_price:.2f}), Risk: {risk_percent*100:.1f}%")
            
            return position_size
            
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return None

    def set_dynamic_exit_points(self, symbol, entry_price, position_type, df):
        """Berechnet dynamische Stop-Loss und Take-Profit Punkte basierend auf der Marktvolatilität"""
        try:
            # Berechne ATR (Average True Range) als Maß für Volatilität
            latest_atr = df['atr'].iloc[-1]
            atr_factor = latest_atr / entry_price
            
            # Anpassen der Stop-Loss und Take-Profit basierend auf ATR
            sl_multiplier = 2.0
            tp_multiplier = 3.5
            
            if position_type == 'long':
                stop_loss_price = entry_price * (1 - (sl_multiplier * atr_factor))
                take_profit_price = entry_price * (1 + (tp_multiplier * atr_factor))
            else:  # short
                stop_loss_price = entry_price * (1 + (sl_multiplier * atr_factor))
                take_profit_price = entry_price * (1 - (tp_multiplier * atr_factor))
            
            # Stelle sicher, dass Stop-Loss nicht zu eng ist
            min_sl_percent = 0.01  # Mindestens 1% vom Eintrittspreis entfernt
            
            if position_type == 'long':
                min_stop_price = entry_price * (1 - min_sl_percent)
                stop_loss_price = min(stop_loss_price, min_stop_price)
            else:
                min_stop_price = entry_price * (1 + min_sl_percent)
                stop_loss_price = max(stop_loss_price, min_stop_price)
            
            # Update der Position mit dynamischen Werten
            self.positions[symbol]['stop_loss'] = stop_loss_price
            self.positions[symbol]['take_profit'] = take_profit_price
            
            logger.info(f"{symbol} dynamic exit points - SL: {stop_loss_price:.4f}, TP: {take_profit_price:.4f}")
            
        except Exception as e:
            logger.error(f"Error setting dynamic exit points for {symbol}: {e}")

    def execute_trade(self, symbol, position_type, current_price, df):
        """Execute a trade (buy/sell) for a specific symbol"""
        try:
            # Berechne Positionsgröße
            position_size = self.calculate_position_size(symbol, current_price)
            
            if position_size is None or position_size <= 0:
                logger.warning(f"Invalid position size for {symbol}, not executing trade")
                return False
            
            # Führe Trade aus
            if position_type == 'long':
                order = self.exchange.create_market_buy_order(
                    symbol=symbol, 
                    amount=position_size
                )
                logger.info(f"{symbol} LONG order executed at ~{current_price:.4f} USDT, Amount: {position_size:.4f}")
            else:  # short
                order = self.exchange.create_market_sell_order(
                    symbol=symbol, 
                    amount=position_size
                )
                logger.info(f"{symbol} SHORT order executed at ~{current_price:.4f} USDT, Amount: {position_size:.4f}")
            
            # Setze dynamische Exit-Punkte
            self.set_dynamic_exit_points(symbol, current_price, position_type, df)
            
            # Update Position-Status
            self.positions[symbol] = {
                'in_position': True,
                'position_type': position_type,
                'position_entry_price': current_price,
                'position_size': position_size,
                'stop_loss': self.positions[symbol]['stop_loss'],
                'take_profit': self.positions[symbol]['take_profit'],
                'entry_time': datetime.now()
            }
            
            return True
            
        except Exception as e:
            logger.error(f"Error executing {position_type} trade for {symbol}: {e}")
            return False

    def close_position(self, symbol, df):
        """Close the current position for a specific symbol"""
        try:
            position = self.positions[symbol]
            if not position['in_position']:
                return False
                
            position_type = position['position_type']
            entry_price = position['position_entry_price']
            position_size = position['position_size']
            entry_time = position['entry_time']
            
            current_price = df['close'].iloc[-1]
            
            # Führe Order aus
            if position_type == 'long':
                order = self.exchange.create_market_sell_order(
                    symbol=symbol, 
                    amount=position_size
                )
            else:  # short
                order = self.exchange.create_market_buy_order(
                    symbol=symbol, 
                    amount=position_size
                )
            
            # Berechne Profit/Loss
            if position_type == 'long':
                profit_loss_percent = (current_price - entry_price) / entry_price * 100
            else:
                profit_loss_percent = (entry_price - current_price) / entry_price * 100
                
            # Leverage-Effekt berücksichtigen
            profit_loss_percent *= self.leverage
            
            logger.info(f"{symbol} {position_type.upper()} position closed at {current_price:.4f}, " 
                       f"P/L: {profit_loss_percent:.2f}% (${position_size * current_price * profit_loss_percent/100:.2f})")
            
            # Zeichne Trade auf
            self.market_analyzer.record_trade(
                symbol=symbol,
                entry_price=entry_price,
                exit_price=current_price,
                position_type=position_type,
                entry_time=entry_time,
                exit_time=datetime.now(),
                profit_loss_percent=profit_loss_percent
            )
            
            # Reset Position
            self.positions[symbol] = {
                'in_position': False,
                'position_type': None,
                'position_entry_price': 0,
                'position_size': 0,
                'stop_loss': None,
                'take_profit': None,
                'entry_time': None
            }
            
            return True
            
        except Exception as e:
            logger.error(f"Error closing position for {symbol}: {e}")
            return False

    def run(self, interval_seconds=60):
        """Main trading loop for multiple cryptocurrencies"""
        logger.info("Enhanced Multi-Crypto Trading Bot started...")
        self.set_leverage()
        
        # Initial market analysis
        self.market_analyzer.analyze_market_state()
        
        # Periodic market correlation update counter
        correlation_counter = 0
        
        while True:
            try:
                # Aktualisiere Marktbedingungen alle 10 Zyklen
                if correlation_counter % 10 == 0:
                    self.market_analyzer.analyze_market_state()
                    self.market_analyzer.calculate_correlations()
                    correlation_counter = 0
                
                correlation_counter += 1
                
                for symbol in self.symbols:
                    # Hole und verarbeite Daten für jedes Symbol
                    df = self.fetch_ohlcv_data(symbol)
                    if df is None or len(df) < max(self.rsi_period, self.short_sma, self.long_sma, 20):
                        logger.warning(f"Insufficient data for {symbol}, skipping...")
                        continue
                    
                    df = self.calculate_indicators(df)
                    current_price = df['close'].iloc[-1]
                    
                    # Periodisches Status-Log
                    if int(time.time()) % (interval_seconds * 10) < interval_seconds:
                        position_status = "No position"
                        if self.positions[symbol]['in_position']:
                            pos_type = self.positions[symbol]['position_type']
                            entry_price = self.positions[symbol]['position_entry_price']
                            if pos_type == 'long':
                                pnl = (current_price - entry_price) / entry_price * 100 * self.leverage
                            else:
                                pnl = (entry_price - current_price) / entry_price * 100 * self.leverage
                            position_status = f"{pos_type.upper()} @ {entry_price:.4f}, P/L: {pnl:.2f}%"
                            
                        logger.info(f"{symbol} | Price: {current_price:.4f} USDT | "
                                  f"RSI: {df['rsi'].iloc[-1]:.1f} | Position: {position_status}")
                    
                    # Prüfe Position und entscheide über Trade
                    if not self.positions[symbol]['in_position']:
                        # Suche nach neuem Trade-Signal
                        trade_signal = self.check_trade_signals(df, symbol)
                        if trade_signal:
                            self.execute_trade(symbol, trade_signal, current_price, df)
                    else:
                        # Update Trailing-Stop
                        self.update_trailing_stop(symbol, current_price)
                        
                        # Prüfe, ob wir die aktuelle Position schließen sollten
                        if self.check_exit_signal(df, symbol):
                            self.close_position(symbol, df)
                
                # Warte vor dem nächsten Durchlauf
                time.sleep(interval_seconds)
            
            except KeyboardInterrupt:
                logger.info("Multi-Crypto Trading Bot stopped by user")
                break
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                time.sleep(interval_seconds)
    
    def run_backtest(self, start_date, end_date, initial_balance=1000):
        """Führt einen Backtest über einen bestimmten Zeitraum durch"""
        logger.info(f"Starting backtest from {start_date} to {end_date} with ${initial_balance} initial balance")
        
        backtest_results = {
            'initial_balance': initial_balance,
            'final_balance': initial_balance,
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'win_rate': 0,
            'profit_factor': 0,
            'symbol_results': {}
        }
        
        # Setze für jeden Symbol zurück
        for symbol in self.symbols:
            backtest_results['symbol_results'][symbol] = {
                'trades': 0,
                'wins': 0,
                'losses': 0,
                'profit': 0,
                'max_drawdown': 0
            }
            
            # Hole historische Daten
            try:
                # Konvertiere Datum zu Timestamp
                start_timestamp = int(datetime.strptime(start_date, "%Y-%m-%d").timestamp() * 1000)
                end_timestamp = int(datetime.strptime(end_date, "%Y-%m-%d").timestamp() * 1000)
                
                # Hole historische Daten
                historical_data = self.exchange.fetch_ohlcv(
                    symbol, 
                    self.timeframe,
                    since=start_timestamp,
                    limit=1000  # Maximale Anzahl von Candles
                )
                
                if not historical_data:
                    logger.warning(f"No historical data available for {symbol}")
                    continue
                    
                # Daten in DataFrame konvertieren
                df = pd.DataFrame(historical_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                
                # Indikatoren berechnen
                df = self.calculate_indicators(df)
                
                # Backtest-Variablen
                in_position = False
                position_type = None
                entry_price = 0
                position_size = 0
                stop_loss = 0
                take_profit = 0
                
                # Durchlaufe die Kerzen
                for i in range(len(df) - 1):
                    current_data = df.iloc[:i+1]
                    next_candle = df.iloc[i+1]
                    current_price = current_data['close'].iloc[-1]
                    
                    # Wenn keine Position offen ist, prüfe auf Einstiegssignal
                    if not in_position:
                        signal = self.check_trade_signals(current_data, symbol)
                        
                        if signal:
                            # Simuliere Einstieg beim Open der nächsten Kerze
                            entry_price = next_candle['open']
                            position_type = signal
                            
                            # Berechne Position Size (vereinfacht für Backtest)
                            risk_amount = backtest_results['final_balance'] * 0.02
                            position_size = risk_amount / (entry_price * self.stop_loss_percent)
                            
                            # Dynamische SL und TP
                            if position_type == 'long':
                                stop_loss = entry_price * (1 - self.stop_loss_percent)
                                take_profit = entry_price * (1 + self.take_profit_percent)
                            else:
                                stop_loss = entry_price * (1 + self.stop_loss_percent)
                                take_profit = entry_price * (1 - self.take_profit_percent)
                                
                            in_position = True
                            logger.info(f"Backtest {symbol} {position_type} entry at {entry_price} on {next_candle['timestamp']}")
                    
                    # Wenn Position offen ist, prüfe auf Ausstiegssignal oder SL/TP
                    else:
                        # Prüfe auf Stop-Loss oder Take-Profit in der nächsten Kerze
                        if position_type == 'long':
                            # Stop-Loss
                            if next_candle['low'] <= stop_loss:
                                exit_price = stop_loss
                                pnl = (exit_price - entry_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} SL hit at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                                
                            # Take-Profit
                            elif next_candle['high'] >= take_profit:
                                exit_price = take_profit
                                pnl = (exit_price - entry_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} TP hit at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                                
                            # Logische Exit-Signale, wie im Live-Trading
                            elif self.check_exit_signal(current_data, symbol):
                                exit_price = next_candle['open']
                                pnl = (exit_price - entry_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} exit signal at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                        
                        else:  # short position
                            # Stop-Loss
                            if next_candle['high'] >= stop_loss:
                                exit_price = stop_loss
                                pnl = (entry_price - exit_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} SL hit at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                                
                            # Take-Profit
                            elif next_candle['low'] <= take_profit:
                                exit_price = take_profit
                                pnl = (entry_price - exit_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} TP hit at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                                
                            # Logische Exit-Signale, wie im Live-Trading
                            elif self.check_exit_signal(current_data, symbol):
                                exit_price = next_candle['open']
                                pnl = (entry_price - exit_price) / entry_price * 100 * self.leverage
                                backtest_results['final_balance'] *= (1 + pnl/100)
                                
                                logger.info(f"Backtest {symbol} exit signal at {exit_price}, P/L: {pnl:.2f}%")
                                
                                # Update Statistiken
                                backtest_results['total_trades'] += 1
                                backtest_results['symbol_results'][symbol]['trades'] += 1
                                
                                if pnl > 0:
                                    backtest_results['winning_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['wins'] += 1
                                else:
                                    backtest_results['losing_trades'] += 1
                                    backtest_results['symbol_results'][symbol]['losses'] += 1
                                    
                                backtest_results['symbol_results'][symbol]['profit'] += pnl
                                
                                in_position = False
                
            except Exception as e:
                logger.error(f"Error in backtest for {symbol}: {e}")
        
        # Berechne abschließende Metriken
        if backtest_results['total_trades'] > 0:
            backtest_results['win_rate'] = backtest_results['winning_trades'] / backtest_results['total_trades']
        
        total_profit = sum(s['profit'] for s in backtest_results['symbol_results'].values() if s['profit'] > 0)
        total_loss = abs(sum(s['profit'] for s in backtest_results['symbol_results'].values() if s['profit'] < 0))
        
        if total_loss > 0:
            backtest_results['profit_factor'] = total_profit / total_loss
        
        logger.info(f"Backtest completed. Initial balance: ${initial_balance}, Final balance: ${backtest_results['final_balance']:.2f}")
        logger.info(f"Total trades: {backtest_results['total_trades']}, Win rate: {backtest_results['win_rate']*100:.2f}%")
        
        return backtest_results

if __name__ == "__main__":
    # Bitget API credentials
    API_KEY = "DEINE_API_KEY_HIER_EINFÜGEN"
    API_SECRET = "DEIN_API_SECRET_HIER_EINFÜGEN"
    API_PASS = "DEIN_API_PASSWORT_HIER_EINFÜGEN"
    
    # Bot initialisieren
    bot = MultiCryptoBot(
        api_key=API_KEY,
        api_secret=API_SECRET,
        password=API_PASS,
        symbols=['SOLUSDT', 'XRPUSDT', 'ETHUSDT', 'BTCUSDT', 'ADAUSDT', 'LINKUSDT'],
        timeframe='15m',
        rsi_period=14,
        rsi_overbought=70,
        rsi_oversold=30,
        short_sma=20,
        long_sma=50,
        stop_loss_percent=2.5,
        take_profit_percent=5.5,
        leverage=5
    )
    
    # Backtest ausführen (optional)
    # backtest_results = bot.run_backtest('2023-01-01', '2023-12-31', initial_balance=1000)
    
    # Live-Trading starten
    bot.run(interval_seconds=60)
